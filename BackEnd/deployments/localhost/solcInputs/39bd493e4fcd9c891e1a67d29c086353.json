{
  "language": "Solidity",
  "sources": {
    "contracts/MessageStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\ncontract MessageStorage {\n    // Struct to represent the structure of a message\n    struct Message {\n        address sender; // Ethereum address of the sender\n        address recipient; // Ethereum address of the recipient\n        string content; // Content of the message\n        uint256 timestamp; // Timestamp when the message was sent\n        bool isRead; // Flag to indicate if the message has been read\n        bool isDeleted; // Flag to indicate if the message has been deleted\n    }\n\n    struct shortMessage {\n        address sender;\n        uint256 timestamp;\n        string content;\n    }\n\n    // Mapping to associate each user's Ethereum address with an array of messages\n    mapping(address => Message[]) public userMessages;\n    mapping(bytes32 => shortMessage[]) public allMessages;\n\n    // Event to emit when a new message is sent\n    event MessageSent(\n        address indexed sender,\n        address indexed recipient,\n        string content\n    );\n\n    // Function to send a new message\n    function sendMessage(address _recipient, string memory _content) public {\n        Message memory newMessage = Message({\n            sender: msg.sender,\n            recipient: _recipient,\n            content: _content,\n            timestamp: block.timestamp,\n            isRead: false,\n            isDeleted: false\n        });\n\n        shortMessage memory newshortMessage = shortMessage({\n            sender: msg.sender,\n            timestamp: block.timestamp,\n            content: _content\n        });\n        bytes32 chatCode = _getChatCode(msg.sender, _recipient);\n\n        userMessages[msg.sender].push(newMessage);\n        userMessages[_recipient].push(newMessage);\n        allMessages[chatCode].push(newshortMessage);\n\n        emit MessageSent(msg.sender, _recipient, _content);\n    }\n\n    function _getChatCode(\n        address _user1,\n        address _user2\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_user1, _user2));\n    }\n\n    // function to return the message from that friend\n    function readFriendMessage(\n        address _friendAddress\n    ) external view returns (shortMessage[] memory) {\n        bytes32 chatCode = _getChatCode(msg.sender, _friendAddress);\n        return allMessages[chatCode];\n    }\n\n    // Function to retrieve all messages for the caller\n    function getMyMessages() public view returns (Message[] memory) {\n        return userMessages[msg.sender];\n    }\n\n    // Function to update the status of a message to \"read\"\n    function markAsRead(uint256 _messageIndex) public {\n        require(\n            _messageIndex < userMessages[msg.sender].length,\n            \"Invalid message index\"\n        );\n\n        userMessages[msg.sender][_messageIndex].isRead = true;\n    }\n\n    function deleteMessage(uint256 _messageIndex) public {\n        require(\n            _messageIndex < userMessages[msg.sender].length,\n            \"Invalid message index\"\n        );\n\n        // Mark the message as deleted\n        userMessages[msg.sender][_messageIndex].isDeleted = true;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}