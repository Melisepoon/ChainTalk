{
  "language": "Solidity",
  "sources": {
    "contracts/UserRegistrationAndAuthentication.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nerror UserNotRegistered();\n\n//0x3a2f83b7b29e34942a4a3211bcb3e8e146c4f779193fc4f3246c41fcf5c221b8\ncontract UserRegistrationAndAuthentication {\n    // Struct to store user information\n    struct User {\n        string name; // User's name\n        string email; // User's email address\n        bytes32 passwordHash; // Hashed password\n        bool isRegistered; // Flag to indicate if the user is registered\n        address[] friendList; // Array to store friend addresses\n    }\n    struct AllUserStruct {\n        string name;\n        address accountAddress;\n    }\n\n    AllUserStruct[] getAllUsers;\n\n    // Mapping to link each user's Ethereum address with their user information\n    mapping(address => User) public users;\n    mapping(address => bool) public userExist;\n\n    // Event to emit when a new user is registered\n    event UserRegistered(\n        address indexed userAddress,\n        string name,\n        string email\n    );\n\n    event FriendAdded(\n        address indexed userAddress,\n        address indexed friendAddress\n    );\n\n    // Function to register a new user\n    function registerUser(\n        string memory _name,\n        string memory _email,\n        bytes32 _passwordHash\n    ) public {\n        require(!users[msg.sender].isRegistered, \"User already registered\");\n        // can add in more checks here like name/email/password cannot be empty\n        User memory newUser = User({\n            name: _name,\n            email: _email,\n            passwordHash: _passwordHash,\n            isRegistered: true,\n            friendList: new address[](0) // to initiate empty friend list\n        });\n        //push details of user into array\n        users[msg.sender] = newUser;\n        getAllUsers.push(AllUserStruct(_name, msg.sender));\n        userExist[msg.sender] = true;\n\n        emit UserRegistered(msg.sender, _name, _email);\n    }\n\n    function checkUserExists() public view returns (bool) {\n        return userExist[msg.sender];\n    }\n\n    // Function to retrieve user information for the caller\n    function getMyUserInfo()\n        public\n        view\n        returns (string memory, string memory, address[] memory)\n    {\n        require(users[msg.sender].isRegistered, \"User not registered\");\n\n        return (\n            users[msg.sender].name,\n            users[msg.sender].email,\n            users[msg.sender].friendList\n        );\n    }\n\n    function checkUserExist(address pubkey) public view returns (bool) {\n        return bytes(users[pubkey].name).length > 0;\n    }\n\n    // GET USERNAME\n    function getUsername(address pubkey) external view returns (string memory) {\n        require(checkUserExist(pubkey), \"User is not registered\");\n        // return the name of user\n        return users[pubkey].name;\n    }\n\n    // Function to authenticate user based on password hash\n    function authenticate(bytes32 _passwordHash) public view returns (bool) {\n        require(users[msg.sender].isRegistered, \"User not registered\");\n\n        return users[msg.sender].passwordHash == _passwordHash;\n    }\n\n    function addFriend(address _friendAddress) public {\n        // check that user is registered\n        require(users[msg.sender].isRegistered, \"User not registered!\");\n        require(\n            msg.sender != _friendAddress,\n            \"User cannot add themselves as friend!\"\n        );\n        if (!users[_friendAddress].isRegistered) revert UserNotRegistered();\n\n        // check if friend already exist in list\n        bool isFriend = false;\n        for (uint256 i = 0; i < users[msg.sender].friendList.length; i++) {\n            if (users[msg.sender].friendList[i] == _friendAddress) {\n                isFriend = true;\n                break;\n            }\n        }\n        require(!isFriend, \"User is already a friend\");\n        users[msg.sender].friendList.push(_friendAddress);\n        emit FriendAdded(msg.sender, _friendAddress);\n\n        //bi-directional friend addition\n        users[_friendAddress].friendList.push(msg.sender);\n        emit FriendAdded(_friendAddress, msg.sender);\n    }\n\n    // GET MY FRIEND\n    function getMyFriendList() public view returns (address[] memory) {\n        require(users[msg.sender].isRegistered, \"User not registered\");\n        return users[msg.sender].friendList;\n    }\n\n    // function to fetch all registered users\n    function getAllAppUser() public view returns (AllUserStruct[] memory) {\n        return getAllUsers;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}