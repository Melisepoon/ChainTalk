{
  "language": "Solidity",
  "sources": {
    "contracts/ChatApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\ncontract ChatApp{\n    // USER struct\n    struct user{\n        string name;\n        friend[] friendList;\n    }\n\n    struct friend{\n        address pubkey;\n        string name;\n    }\n\n    struct message{\n        address sender;\n        uint256 timestamp;\n        string msg;\n    }\n\n    struct AllUserStruct{\n        string name;\n        address accountAddress;\n    }\n\n    AllUserStruct[] getAllUsers;\n\n    mapping(address => user) userList;\n    // provide all communication that is happening btw 2 users\n    mapping(bytes32 => message[]) allMessages;\n\n    // CHECK USER EXIST\n    function checkUserExist (address pubkey) public view returns(bool){\n        return bytes(userList[pubkey].name).length > 0;\n    }\n\n    // CREATE ACCOUNT\n    function createAccount(string calldata name)external{\n        // have to be user then can create account\n        require(checkUserExist(msg.sender)==false, \"User already exisit\");\n        require(bytes(name).length>0,\"Username cannot be empty\");\n\n        // push name of user into array\n        userList[msg.sender].name = name;\n        getAllUsers.push(AllUserStruct(name,msg.sender));\n    }\n\n    // GET USERNAME\n    function getUsername(address pubkey) external view returns (string memory){\n        require(checkUserExist(pubkey), \"User is not registered\");\n        // return the name of user\n        return userList[pubkey].name;\n    }\n\n    // ADD FRIENDS\n    function addFriend(address friend_key, string calldata name)external{\n        // check that the person you want to add as friend has account\n        require(checkUserExist(msg.sender),\"Create an account first\");\n        // check that person that is trying to add friend has account\n        require(checkUserExist(friend_key), \"User is not registered\");\n        // check that you are adding new friend and not yourself\n        require (msg.sender != friend_key, \"User cannot add themselves as friends\");\n        // check if they are already friends\n        require(checkAlreadyFriends(msg.sender,friend_key)== false, \"These users are already friends\");\n\n        _addFriend(msg.sender,friend_key,name);\n        _addFriend(friend_key,msg.sender,userList[msg.sender].name);\n    }\n\n    function checkAlreadyFriends(address pubkey1, address pubkey2)internal view returns(bool){\n\n        if (userList[pubkey1].friendList.length > userList[pubkey2].friendList.length){\n            address tmp = pubkey1;\n            pubkey1 = pubkey2;\n            pubkey2 = tmp;\n        }\n\n        for (uint256 i = 0; i< userList[pubkey1].friendList.length;i++){\n            if (userList[pubkey1].friendList[i].pubkey==pubkey2)return true;\n        }\n        return false;\n    }\n\n    function _addFriend(address me, address friend_key, string memory name) internal{\n        friend memory newFriend = friend(friend_key,name);\n        userList[me].friendList.push(newFriend);\n    }\n\n    // GET MY FRIEND\n    function getMyFriendList() external view returns(friend[]memory){\n        return userList[msg.sender].friendList;\n    }\n\n    // GET CHAT CODE (run internally)\n    function _getChatCode (address pubkey1, address pubkey2) internal pure returns(bytes32){\n        if (pubkey1<pubkey2){\n            return keccak256(abi.encodePacked(pubkey1,pubkey2));\n        }else return keccak256(abi.encodePacked(pubkey2,pubkey1));\n    }\n\n    // send message\n    function sendMessage(address friend_key, string calldata _msg) external{\n        require(checkUserExist(msg.sender),\"Create an account first\");\n        require(checkUserExist(friend_key), \"User is not registered\");\n        require(checkAlreadyFriends(msg.sender,friend_key), \"You are not friends with the given user\");\n\n        bytes32 chatCode = _getChatCode(msg.sender,friend_key);\n        message memory newMsg = message(msg.sender,block.timestamp, _msg);\n        allMessages[chatCode].push(newMsg);\n    }\n\n    // READ MESSAGE\n    function readMessage (address friend_key) external view returns(message[] memory){\n        bytes32 chatCode = _getChatCode(msg.sender,friend_key);\n        return allMessages[chatCode];\n    }\n\n    // TO FETCH ALL REGISTERED USERS\n    function getAllAppUser() public view returns (AllUserStruct[] memory){\n        return getAllUsers;\n    }\n}"
    },
    "contracts/Encryption.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.21;\n\n// contract Encryption {\n//     // Mapping to store the public keys of users\n//     mapping(address => bytes) public publicKeys;\n\n//     // Event to emit when a new public key is set\n//     event PublicKeySet(address indexed userAddress, bytes publicKey);\n\n//     // Function to generate and set the public key for a user\n//     function setPublicKey(bytes memory _publicKey) public {\n//         publicKeys[msg.sender] = _publicKey;\n\n//         emit PublicKeySet(msg.sender, _publicKey);\n//     }\n\n//     // Function to encrypt a message using the recipient's public key\n//     function encryptMessage(\n//         address _recipient,\n//         string memory _message\n//     ) public view returns (bytes memory) {\n//         require(\n//             publicKeys[_recipient].length > 0,\n//             \"Recipient's public key not set\"\n//         );\n\n//         // Encrypt the message using the recipient's public key (pseudocode)\n//         bytes memory encryptedMessage = encrypt(\n//             _message,\n//             publicKeys[_recipient]\n//         );\n\n//         return encryptedMessage;\n//     }\n// }\n\n// contract Decryption {\n//     // Mapping to store the private keys of users\n//     mapping(address => bytes) private privateKeys;\n\n//     // Function to generate and set the private key for a user\n//     function setPrivateKey(bytes memory _privateKey) public {\n//         privateKeys[msg.sender] = _privateKey;\n//     }\n\n//     // Function to decrypt a message using the recipient's private key\n//     function decryptMessage(\n//         bytes memory _encryptedMessage\n//     ) public view returns (string memory) {\n//         require(privateKeys[msg.sender].length > 0, \"Private key not set\");\n\n//         // Decrypt the message using the recipient's private key (pseudocode)\n//         string memory decryptedMessage = decrypt(\n//             _encryptedMessage,\n//             privateKeys[msg.sender]\n//         );\n\n//         return decryptedMessage;\n//     }\n// }\n"
    },
    "contracts/MessageStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\ncontract MessageStorage {\n    // Struct to represent the structure of a message\n    struct Message {\n        address sender; // Ethereum address of the sender\n        address recipient; // Ethereum address of the recipient\n        string content; // Content of the message\n        uint256 timestamp; // Timestamp when the message was sent\n        bool isRead; // Flag to indicate if the message has been read\n        bool isDeleted; // Flag to indicate if the message has been deleted\n    }\n\n    // Mapping to associate each user's Ethereum address with an array of messages\n    mapping(address => Message[]) public userMessages;\n\n    // Event to emit when a new message is sent\n    event MessageSent(\n        address indexed sender,\n        address indexed recipient,\n        string content\n    );\n\n    // Function to send a new message\n    function sendMessage(address _recipient, string memory _content) public {\n        Message memory newMessage = Message({\n            sender: msg.sender,\n            recipient: _recipient,\n            content: _content,\n            timestamp: block.timestamp,\n            isRead: false,\n            isDeleted: false\n        });\n\n        userMessages[msg.sender].push(newMessage);\n        userMessages[_recipient].push(newMessage);\n\n        emit MessageSent(msg.sender, _recipient, _content);\n    }\n\n    // Function to retrieve all messages for the caller\n    function getMyMessages() public view returns (Message[] memory) {\n        return userMessages[msg.sender];\n    }\n\n    // Function to update the status of a message to \"read\"\n    function markAsRead(uint256 _messageIndex) public {\n        require(\n            _messageIndex < userMessages[msg.sender].length,\n            \"Invalid message index\"\n        );\n\n        userMessages[msg.sender][_messageIndex].isRead = true;\n    }\n\n    function deleteMessage(uint256 _messageIndex) public {\n        require(\n            _messageIndex < userMessages[msg.sender].length,\n            \"Invalid message index\"\n        );\n\n        // Mark the message as deleted\n        userMessages[msg.sender][_messageIndex].isDeleted = true;\n    }\n}\n"
    },
    "contracts/UserRegistrationAndAuthentication.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nerror UserNotRegistered();\n\n//0x3a2f83b7b29e34942a4a3211bcb3e8e146c4f779193fc4f3246c41fcf5c221b8\ncontract UserRegistrationAndAuthentication {\n    // Struct to store user information\n    struct User {\n        string name; // User's name\n        string email; // User's email address\n        bytes32 passwordHash; // Hashed password\n        bool isRegistered; // Flag to indicate if the user is registered\n        address[] friendList; // Array to store friend addresses\n    }\n\n    // Mapping to link each user's Ethereum address with their user information\n    mapping(address => User) public users;\n\n    // Event to emit when a new user is registered\n    event UserRegistered(\n        address indexed userAddress,\n        string name,\n        string email\n    );\n\n    event FriendAdded(\n        address indexed userAddress,\n        address indexed friendAddress\n    );\n\n    // Function to register a new user\n    function registerUser(\n        string memory _name,\n        string memory _email,\n        bytes32 _passwordHash\n    ) public {\n        require(!users[msg.sender].isRegistered, \"User already registered\");\n        // can add in more checks here like name/email/password cannot be empty\n        User memory newUser = User({\n            name: _name,\n            email: _email,\n            passwordHash: _passwordHash,\n            isRegistered: true,\n            friendList: new address[](0) // to initiate empty friend list\n        });\n        //push details of user into array\n        users[msg.sender] = newUser;\n\n        emit UserRegistered(msg.sender, _name, _email);\n    }\n\n    // Function to retrieve user information for the caller\n    function getMyUserInfo()\n        public\n        view\n        returns (string memory, string memory,address[]memory)\n    {\n        require(users[msg.sender].isRegistered, \"User not registered\");\n\n        return (users[msg.sender].name, users[msg.sender].email, users[msg.sender].friendList);\n    }\n\n    // Function to authenticate user based on password hash\n    function authenticate(bytes32 _passwordHash) public view returns (bool) {\n        require(users[msg.sender].isRegistered, \"User not registered\");\n\n        return users[msg.sender].passwordHash == _passwordHash;\n    }\n\n    function addFriend(address _friendAddress) public {\n        // check that user is registered\n        require(users[msg.sender].isRegistered, \"User not registered!\");\n        require(\n            msg.sender != _friendAddress,\n            \"User cannot add themselves as friend!\"\n        );\n        if (!users[_friendAddress].isRegistered) revert UserNotRegistered();\n\n        // check if friend already exist in list\n        bool isFriend = false;\n        for (uint256 i = 0; i < users[msg.sender].friendList.length; i++) {\n            if(users[msg.sender].friendList[i]==_friendAddress){\n                isFriend = true;\n                break;\n            }\n        }\n        require(!isFriend,\"User is already a friend\");\n        users[msg.sender].friendList.push(_friendAddress);\n        emit FriendAdded(msg.sender,_friendAddress);\n\n        //bi-directional friend addition\n        users[_friendAddress].friendList.push(msg.sender);\n        emit FriendAdded(_friendAddress,msg.sender);\n    }\n    // GET MY FRIEND\n    function getMyFriendList() public view returns(address[]memory){\n        require(users[msg.sender].isRegistered,\"User not registered\");\n        return users[msg.sender].friendList;\n    }\n\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}